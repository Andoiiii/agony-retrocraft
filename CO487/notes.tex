\documentclass[class=co487,notes]{agony}
\declaretheorem[name=Cryptoscheme,refname={scheme,scheme},style=thmroundgreen]{scheme}

\title{CO 487 Winter 2024: Lecture Notes}
\begin{document}
\renewcommand{\contentsname}{CO 487 Winter 2024:\\{\huge Lecture Notes}}
\thispagestyle{firstpage}
\tableofcontents

Lecture notes taken, unless otherwise specified,
by myself during the Winter 2024 offering of CO 487,
taught by Alfred Menezes.

\begin{multicols}{2}
  \listoflecture
\end{multicols}

\chapter{Introduction}
\lecture{Jan 8}

Cryptography is securing communications in the presence of malicious adversaries.
To simplify, consider Alice and Bob communicating with the eavesdropper Eve.
Communications should be:
\begin{itemize}
  \item Confidential: Only authorized people can read it
  \item Integral: Ensured that it is unmodified
  \item Origin authenticated: Ensured that the source is in fact Alice
  \item Non-repudiated: Unable to gaslight the message existing
\end{itemize}
Examples: TLS for intenet browsing, GSM for cell phone communications,
Bluetooth for other wireless devices.

\paragraph{Overview: Transport Layer Security} The protocol used by browsers
to visit websites.
TLS assures an individual user (a \term{client})
of the authenticity of the website (a \term{server})
and to establish a secure communications \term{session}.

TLS uses \term{symmetric-key cryptography}.
Both the client and server have a shared secret $k$ called a \term{key}.
They can then use AES for encryption and HMAC for authentication.

To establish the shared secret, use \term{public-key cryptography}.
Alice can encrypt the session key $k$ can be encrypted with Bob's RSA public key.
Then, Bob can decrypt it with his private key.

To ensure Alice is getting an authentic copy of Bob's public key,
a \term{certification authority} (CA) signs it using the CA's private key.
The CA public key comes with Alice's device preinstalled.

Potential vulnerabilities when using TLS:
\begin{itemize}
  \item Weak cryptography scheme or vulnerable to quantum computing
  \item Weak random number generation for the session key
  \item Fraudulent certificates
  \item Implementation bugs
  \item Phishing attacks
  \item Transmission is secured, but the endpoints are not
\end{itemize}
These are mostly the purview of cybersecurity,
of which cryptography is a part.
Cryptography is not typically the weakest link in the cybersecurity chain.

\chapter{Symmetric Key Encryption}
\lecture{Jan 10}

\section{Basic concepts}

\begin{defn}[symmetric-key encryption scheme]
  A \term*{symmetric-key encryption scheme} (SKES) consists of:
  \begin{itemize}[nosep]
    \item plaintext space $M$,
    \item ciphertext space $C$,
    \item key space $K$,
    \item family of encryption functions $E_k : M \to C$ for all keys $k \in K$, and
    \item family of decryption functions $D_k : C \to M$ for all keys $k \in K$
  \end{itemize}
  such that $D_k(E_k(m)) = m$ for all $m$ and $k$.
\end{defn}

For Alice to send a message to Bob:
\begin{enumerate}[1.,nosep]
  \item Alice and Bob agree on a secret key $k$ \emph{somehow} (assume a secured channel)
  \item Alice computes $c = E_k(m)$ and sends $c$ to Bob
  \item Bob recovers the plaintext by computing $m = D_k(c)$
\end{enumerate}

Examples include the Enigma and Lorenz machines.

\begin{scheme}[simple substitution cipher]
  Let:
  \begin{itemize}[nosep]
    \item $M$ be English messages
    \item $C$ be encrypted messages
    \item $K$ be permutations of the English alphabet
    \item $E_k(m)$ apply the permutation $k$ to $m$, one letter at a time
    \item $D_k(c)$ apply the inverse permutation $k^{-1}$ to $c$, one letter at a time
  \end{itemize}
\end{scheme}

We want a system to have:
\begin{enumerate}[nosep]
  \item Efficient algorithms should be known for computing (encryption and decryption)
  \item Small keys but large enough to render exhaustive key search infeasible
  \item Security
  \item Security against its designer
\end{enumerate}

To determine how secure the protocol is, we have to define security.

\begin{defn}[security model]
  Some parameters which define the strength of the adversary,
  specific interaction with the ``secure'' channel,
  and the goal of the adversary.
\end{defn}

Some options for strength:
\begin{itemize}[nosep]
  \item \term{Information-theoretic security}: Eve has infinite resources.
  \item \term{Complexity-theoretic security}: Eve is a polynomimal-time Turing machine.
  \item \term{Computational-theoretic security}: Eve has a specific amount of computing power.
        In this course, Eve is \term{computationally bounded} by
        6,768 Intel E5-2683 V4 cores running at 2.1 GHz at her disposal.
\end{itemize}
For the interaction:
\begin{itemize}[nosep]
  \item \term{Ciphertext-only attack}: Eve only knows the ciphertext.
  \item \term{Known-plaintext attack}: Eve knows some plaintext and the corresponding ciphertext.
  \item \term{Chosen-plaintext attack}: Eve picks some plaintext and knows the corresponding ciphertext.
  \item \term{Clanedestine attack}: Eve resorts to bribery, blackmail, etc.
  \item \term{Side-channel attack}: Eve has physical access to hardware and has some monitoring data.
\end{itemize}
And for the goal:
\begin{itemize}[nosep]
  \item Recovering the secret key $k$
  \item Systematically decrypt arbitrary ciphertexts without knowing $k$ (\term{total security})
  \item Learn partial information about the plaintext (other than the length) (\term{semantic security})
\end{itemize}

\begin{defn}[security]
  An SKES is \term{secure} if it is semantically secure against a chosen-plaintext attack
  by a computationally bounded adversary.
\end{defn}

Equivalently, an SKES is \term{broken} if:
\begin{enumerate}[nosep]
  \item Given a challenge ciphertext $c$ for $m$ generated by Alice,
  \item \dots and access to an encryption oracle for Alice,
  \item \dots Eve can obtain some information about $m$ other than its length,
  \item \dots using only a feasible amount of computation.
\end{enumerate}
Note: this is IND--CPA from CO 485.

\begin{example}
  Is the simple substitution cipher secure?
  What about under a ciphertext-only attack?
\end{example}
\begin{sol}
  Under CPA, encrypt the entire alphabet.
  Then, the entire key $k$ is recovered.

  With a ciphertext-only attack, an exhaustive key search would take
  $26! \approx 2^{88}$ attempts.
  This would take over 1,000 years, which is pretty infeasible,
  so it is secure.
\end{sol}

Can we quantify how feasible something is?

\begin{defn}[security level]
  A scheme has a \term{security level} of $\ell$ bits if
  the fastest known attack on the scheme takes approximately $2^\ell$ operations.
\end{defn}

\begin{convention}
  In this course:
  \begin{itemize}[nosep]
    \item 40 bits is very easy to break
    \item 56 bits is easy to break
    \item 64 bits is feasible to break
    \item 80 bits is barely feasible to break
    \item 128 bits is infeasible to break
  \end{itemize}
\end{convention}

\lecture{Jan 12}
The simple substitution cipher can be attacked by frequency analysis,
since, for example, if ``e'' is the most common English letter,
we check the ciphertext for the most common letter and identify it with ``e''.

\begin{scheme}[Vigen√®re cipher]
  Let the key $K$ be an English word with no repeated letters, e.g., $K = \symrm{CRYPTO}$.

  To encrypt, add letter-wise the key modulo 26, where $k$ is $K$ repeated until
  it matches the length of the message:
  \begin{center}
    \begin{tabular}{rcccccccccccccc}
      $m =$        & t & h & i & s & i & s & a & m & e & s & s & a & g & e \\
      $+\quad k =$ & C & R & Y & P & T & O & C & R & Y & P & T & O & C & R \\ \hline
      $c =$        & V & Y & G & H & B & G & C & D & C & H & L & O & I & V
    \end{tabular}
  \end{center}
  To decrypt, just take $c - k$.
\end{scheme}

This solves our frequency analysis problem.
However, the Vigenere cipher is still totally insecure.

\begin{xca}
  Show that the Vigenere cipher is totally insecure under a chosen-plaintext attack
  and a ciphertext-only attack.
\end{xca}

\begin{scheme}[one-time pad]
  The key is a random string of letters with the same length as the message.

  Repeat the process for Vigenere.
  To encode, add each letter.
  To decode, subtract each letter.
\end{scheme}

\begin{example}
  We can encrypt as follows:
  \begin{center}
    \begin{tabular}{rcccccccccccccc}
      $m =$        & t & h & i & s & i & s & a & m & e & s & s & a & g & e \\
      $+\quad k =$ & Z & F & K & W & O & G & P & S & M & F & J & D & L & G \\ \hline
      $c =$        & S & M & S & P & W & Y & P & F & Q & X & C & D & R & K \\
    \end{tabular}
  \end{center}
\end{example}

This is semantically secure as long as the key is never reused.
Formally, there exist keys that can decrypt the ciphertext into \emph{anything},
so there is no way for an attacker to know the plaintext.
If it is reused, i.e., if $c_1 = m_1 + k$ and $c_2 = m_2 + k$,
then $c_1 - c_2 = (m_1 + k) - (m_2 + k) = m_1 - m_2$.
Since this is a function only of messages, it can leak frequency information etc.

Also, since the key is never reused, this is secure against a chosen plaintext attack,
since one would only recover the already used key.

\begin{convention}
  From now on, messages and keys are assumed to be binary strings.
\end{convention}

\begin{defn}[bitwise exclusive or]
  For two bitstrings $x,y \in \{0,1\}^n \cong \Z/2\Z^n$,
  the bitwise XOR $x \xor y$ is just addition mod 2.
\end{defn}

Unfortunately, due to Shannon, we have this theorem:

\begin{theorem}
  A perfectly secure symmetric-key scheme must have
  at least as many keys as there are messages.
\end{theorem}

\section{Stream ciphers}

Instead of using a random key in the OTP, use a pseudorandom key.

\begin{defn}[pseudorandomness]
  A \term*{pseudorandom bit generator} (PBRG) is a deterministic algorithm
  that takes as input a \term{seed} and outputs a \term*{pseudorandom} sequence called
  the \term{keystream}.
\end{defn}

Then, we can construct a stream cipher by defining the key as the seed
and the ciphertext as the keystream XOR'd with the plaintext.
To decrypt, use the seed to generate the same keystream and XOR with the ciphertext.

For a stream cipher to be secure, we need:
\begin{itemize}
  \item Indistinguishability: the keystream is indistinguishable from a
        truly random sequence; and
  \item Unpredictability: given a partial keystream, it is infeasible to learn
        any information from the remainder of the keystream.
\end{itemize}

\begin{remark}
  Do not use built-in UNIX \texttt{rand} or \texttt{srand} for cryptography!
\end{remark}

\subsection{ChaCha20}

The algorithm works entirely on words (32-bit numbers).

\begin{scheme}[ChaCha20]
  First, define a helper function $QR(a,b,c,d)$ on 32-bit words:
  \begin{enumerate}[nosep]
    \item $a \gets a \modplus b$, $d \gets d \xor a$, $d \gets d \lll 16$
    \item $c \gets c \modplus d$, $b \gets b \xor c$, $b \gets b \lll 12$
    \item $a \gets a \modplus b$, $d \gets d \xor a$, $d \gets d \lll 8$
    \item $c \gets c \modplus d$, $b \gets b \xor c$, $b \gets b \lll 7$
  \end{enumerate}
  where $\xor$ is bitwise XOR, $\modplus$ is addition mod $2^{32}$, and $\lll$ is left bit-rotation.

  Given a 256-bit key $k = (k_1,\dotsc,k_8)$,
  a selected 96-bit nonce $n = (n_1,n_2,n_3)$,
  a 128-bit given constant $f = (f_1,\dotsc,f_4)$,
  and 32-bit counter $c \gets 0$, construct an initial state:
  \[
    S := \begin{bmatrix}
      f_1 & f_2 & f_3 & f_4 \\
      k_1 & k_2 & k_3 & k_4 \\
      k_5 & k_6 & k_7 & k_8 \\
      c   & n_1 & n_2 & n_3
    \end{bmatrix} = \begin{bmatrix}
      S_1    & S_2    & S_3    & S_4    \\
      S_5    & S_6    & S_7    & S_8    \\
      S_9    & S_{10} & S_{11} & S_{12} \\
      S_{13} & S_{14} & S_{15} & S_{16}
    \end{bmatrix}
  \]
  Keep a copy $S' \gets S$, then apply:
  \begin{gather*}
    QR(S_{1}, S_{5}, S_{9}, S_{13}),\quad QR(S_{2}, S_{6}, S_{10}, S_{14}),\quad QR(S_{3}, S_{7}, S_{11}, S_{15}),\quad QR(S_{4}, S_{8}, S_{12}, S_{16}) \\
    QR(S_{1}, S_{6}, S_{11}, S_{16}),\quad QR(S_{2}, S_{7}, S_{12}, S_{13}),\quad QR(S_{3}, S_{8}, S_{9}, S_{14}),\quad QR(S_{4}, S_{5}, S_{10}, S_{15})
  \end{gather*}
  ten times (for 80 total calls to $QR$) and output $S \xor S'$.
  This gives us 64 keystream bytes.

  Increment $c \gets c+1$ and repeat as necessary to generate more keystream bytes.

  To encrypt, XOR the keystream with the plaintext, then append the nonce.

  To decrypt, pop off the nonce, then XOR the keystream with the ciphertext.
\end{scheme}

\end{document}
