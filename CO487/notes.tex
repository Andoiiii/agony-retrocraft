\documentclass[class=co487,notes]{agony}
\declaretheorem[name=Cryptoscheme,refname={scheme,scheme},style=thmroundgreen]{scheme}

\title{CO 487 Winter 2024: Lecture Notes}
\begin{document}
\renewcommand{\contentsname}{CO 487 Winter 2024:\\{\huge Lecture Notes}}
\thispagestyle{firstpage}
\tableofcontents

Lecture notes taken, unless otherwise specified,
by myself during the Winter 2024 offering of CO 487,
taught by Alfred Menezes.

\begin{multicols}{2}
  \listoflecture
\end{multicols}

\chapter{Introduction}
\lecture{Jan 8}

Cryptography is securing communications in the presence of malicious adversaries.
To simplify, consider Alice and Bob communicating with the eavesdropper Eve.
Communications should be:
\begin{itemize}
  \item Confidential: Only authorized people can read it
  \item Integral: Ensured that it is unmodified
  \item Origin authenticated: Ensured that the source is in fact Alice
  \item Non-repudiated: Unable to gaslight the message existing
\end{itemize}
Examples: TLS for intenet browsing, GSM for cell phone communications,
Bluetooth for other wireless devices.

\paragraph{Overview: Transport Layer Security} The protocol used by browsers
to visit websites.
TLS assures an individual user (a \term{client})
of the authenticity of the website (a \term{server})
and to establish a secure communications \term{session}.

TLS uses \term{symmetric-key cryptography}.
Both the client and server have a shared secret $k$ called a \term{key}.
They can then use AES for encryption and HMAC for authentication.

To establish the shared secret, use \term{public-key cryptography}.
Alice can encrypt the session key $k$ can be encrypted with Bob's RSA public key.
Then, Bob can decrypt it with his private key.

To ensure Alice is getting an authentic copy of Bob's public key,
a \term{certification authority} (CA) signs it using the CA's private key.
The CA public key comes with Alice's device preinstalled.

Potential vulnerabilities when using TLS:
\begin{itemize}
  \item Weak cryptography scheme or vulnerable to quantum computing
  \item Weak random number generation for the session key
  \item Fraudulent certificates
  \item Implementation bugs
  \item Phishing attacks
  \item Transmission is secured, but the endpoints are not
\end{itemize}
These are mostly the purview of cybersecurity,
of which cryptography is a part.
Cryptography is not typically the weakest link in the cybersecurity chain.

\chapter{Symmetric Key Encryption}
\lecture{Jan 10}

\section{Basic concepts}

\begin{defn}[symmetric-key encryption scheme]
  A \term*{symmetric-key encryption scheme} (SKES) consists of:
  \begin{itemize}[nosep]
    \item plaintext space $M$,
    \item ciphertext space $C$,
    \item key space $K$,
    \item family of encryption functions $E_k : M \to C$ for all keys $k \in K$, and
    \item family of decryption functions $D_k : C \to M$ for all keys $k \in K$
  \end{itemize}
  such that $D_k(E_k(m)) = m$ for all $m$ and $k$.
\end{defn}

For Alice to send a message to Bob:
\begin{enumerate}[1.,nosep]
  \item Alice and Bob agree on a secret key $k$ \emph{somehow} (assume a secured channel)
  \item Alice computes $c = E_k(m)$ and sends $c$ to Bob
  \item Bob recovers the plaintext by computing $m = D_k(c)$
\end{enumerate}

Examples include the Enigma and Lorenz machines.

\begin{scheme}[simple substitution cipher]
  Let:
  \begin{itemize}[nosep]
    \item $M$ be English messages
    \item $C$ be encrypted messages
    \item $K$ be permutations of the English alphabet
    \item $E_k(m)$ apply the permutation $k$ to $m$, one letter at a time
    \item $D_k(c)$ apply the inverse permutation $k^{-1}$ to $c$, one letter at a time
  \end{itemize}
\end{scheme}

We want a system to have:
\begin{enumerate}[nosep]
  \item Efficient algorithms should be known for computing (encryption and decryption)
  \item Small keys but large enough to render exhaustive key search infeasible
  \item Security
  \item Security against its designer
\end{enumerate}

To determine how secure the protocol is, we have to define security.

\begin{defn}[security model]
  Some parameters which define the strength of the adversary,
  specific interaction with the ``secure'' channel,
  and the goal of the adversary.
\end{defn}

Some options for strength:
\begin{itemize}[nosep]
  \item \term{Information-theoretic security}: Eve has infinite resources.
  \item \term{Complexity-theoretic security}: Eve is a polynomimal-time Turing machine.
  \item \term{Computational-theoretic security}: Eve has a specific amount of computing power.
        In this course, Eve is \term{computationally bounded} by
        6,768 Intel E5-2683 V4 cores running at 2.1 GHz at her disposal.
\end{itemize}
For the interaction:
\begin{itemize}[nosep]
  \item \term{Ciphertext-only attack}: Eve only knows the ciphertext.
  \item \term{Known-plaintext attack}: Eve knows some plaintext and the corresponding ciphertext.
  \item \term{Chosen-plaintext attack}: Eve picks some plaintext and knows the corresponding ciphertext.
  \item \term{Clanedestine attack}: Eve resorts to bribery, blackmail, etc.
  \item \term{Side-channel attack}: Eve has physical access to hardware and has some monitoring data.
\end{itemize}
And for the goal:
\begin{itemize}[nosep]
  \item Recovering the secret key $k$
  \item Systematically decrypt arbitrary ciphertexts without knowing $k$ (\term{total security})
  \item Learn partial information about the plaintext (other than the length) (\term{semantic security})
\end{itemize}

\begin{defn}[security]
  An SKES is \term{secure} if it is semantically secure against a chosen-plaintext attack
  by a computationally bounded adversary.
\end{defn}

Equivalently, an SKES is \term{broken} if:
\begin{enumerate}[nosep]
  \item Given a challenge ciphertext $c$ for $m$ generated by Alice,
  \item \dots and access to an encryption oracle for Alice,
  \item \dots Eve can obtain some information about $m$ other than its length,
  \item \dots using only a feasible amount of computation.
\end{enumerate}
Note: this is IND--CPA from CO 485.

\begin{example}
  Is the simple substitution cipher secure?
  What about under a ciphertext-only attack?
\end{example}
\begin{sol}
  Under CPA, encrypt the entire alphabet.
  Then, the entire key $k$ is recovered.

  With a ciphertext-only attack, an exhaustive key search would take
  $26! \approx 2^{88}$ attempts.
  This would take over 1,000 years, which is pretty infeasible,
  so it is secure.
\end{sol}

Can we quantify how feasible something is?

\begin{defn}[security level]
  A scheme has a \term{security level} of $\ell$ bits if
  the fastest known attack on the scheme takes approximately $2^\ell$ operations.
\end{defn}

\begin{convention}
  In this course:
  \begin{itemize}[nosep]
    \item 40 bits is very easy to break
    \item 56 bits is easy to break
    \item 64 bits is feasible to break
    \item 80 bits is barely feasible to break
    \item 128 bits is infeasible to break
  \end{itemize}
\end{convention}


\end{document}
